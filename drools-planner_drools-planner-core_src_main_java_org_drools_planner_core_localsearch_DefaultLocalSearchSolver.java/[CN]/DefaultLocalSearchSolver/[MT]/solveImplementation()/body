{
  LocalSearchSolverScope localSearchSolverScope=this.localSearchSolverScope;
  solvingStarted(localSearchSolverScope);
  StepScope stepScope=createNextStepScope(localSearchSolverScope,null);
  while (!terminatedEarly.get() && !termination.isTerminated(stepScope)) {
    stepScope.setTimeGradient(termination.calculateTimeGradient(stepScope));
    beforeDeciding(stepScope);
    decider.decideNextStep(stepScope);
    Move nextStep=stepScope.getStep();
    if (nextStep == null) {
      logger.warn("No move accepted for step index ({}) out of {} accepted moves. Terminating by exception.",stepScope.getStepIndex(),decider.getForager().getAcceptedMovesSize());
      break;
    }
    String nextStepString=null;
    if (logger.isInfoEnabled()) {
      nextStepString=nextStep.toString();
    }
    stepDecided(stepScope);
    nextStep.doMove(stepScope.getWorkingMemory());
    localSearchSolverScope.getWorkingSolution().setScore(stepScope.getScore());
    if (assertStepScoreIsUncorrupted) {
      localSearchSolverScope.assertWorkingScore(stepScope.getScore());
    }
    stepTaken(stepScope);
    logger.info("Step index ({}), time spend ({}), score ({}), {} best score ({}), accepted move size ({}) for picked step ({}).",new Object[]{stepScope.getStepIndex(),localSearchSolverScope.calculateTimeMillisSpend(),stepScope.getScore(),(stepScope.getBestScoreImproved() ? "new" : "   "),localSearchSolverScope.getBestScore(),decider.getForager().getAcceptedMovesSize(),nextStepString});
    stepScope=createNextStepScope(localSearchSolverScope,stepScope);
  }
  solvingEnded(localSearchSolverScope);
}
