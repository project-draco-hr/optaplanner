{
  Collection<? extends Object> checkingTabus=findTabu(moveScope);
  int maximumTabuStepIndex=-1;
  for (  Object checkingTabu : checkingTabus) {
    Integer tabuStepIndexInteger=tabuToStepIndexMap.get(checkingTabu);
    if (tabuStepIndexInteger != null) {
      maximumTabuStepIndex=Math.max(tabuStepIndexInteger,maximumTabuStepIndex);
    }
    if (assertTabuHashCodeCorrectness) {
      for (      Object tabu : tabuSequenceList) {
        if (tabu.equals(checkingTabu)) {
          if (tabu.hashCode() != checkingTabu.hashCode()) {
            throw new IllegalStateException("HashCode violation: tabu (" + tabu + ") and checkingTabu ("+ checkingTabu+ ") are equal but have a different hashCode.");
          }
          if (tabuStepIndexInteger == null) {
            throw new IllegalStateException("HashCode violation: the hashCode of tabu (" + tabu + ") probably changed since it was inserted in the tabu Map or Set.");
          }
        }
      }
    }
  }
  if (maximumTabuStepIndex < 0) {
    return 1.0;
  }
  if (aspirationEnabled) {
    if (moveScope.getScore().compareTo(moveScope.getLocalSearchStepScope().getLocalSearchSolverPhaseScope().getBestScore()) > 0) {
      logger.trace("        Proposed move ({}) is tabu, but aspiration undoes its tabu.",moveScope.getMove());
      return 1.0;
    }
  }
  int tabuStepCount=moveScope.getLocalSearchStepScope().getStepIndex() - maximumTabuStepIndex - 1;
  if (tabuStepCount < completeTabuSize) {
    logger.trace("        Proposed move ({}) is complete tabu.",moveScope.getMove());
    return 0.0;
  }
  double acceptChance=calculatePartialTabuAcceptChance(tabuStepCount - completeTabuSize);
  logger.trace("        Proposed move ({}) is partially tabu with accept chance ({}).",moveScope.getMove(),acceptChance);
  return acceptChance;
}
