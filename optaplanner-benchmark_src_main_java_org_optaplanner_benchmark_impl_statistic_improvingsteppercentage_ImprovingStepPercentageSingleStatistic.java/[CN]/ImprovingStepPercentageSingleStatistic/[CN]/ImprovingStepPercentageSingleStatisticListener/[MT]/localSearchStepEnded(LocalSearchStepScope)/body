{
  Move step=stepScope.getStep();
  Class<? extends Move> moveType=step.getClass();
  increaseByOne(totalCounts,moveType);
  if (stepScope.getBestScoreImproved()) {
    increaseByOne(improvementCounts,moveType);
  }
  long timeMillisSpend=stepScope.getPhaseScope().calculateSolverTimeMillisSpend();
  if (timeMillisSpend < nextTimeMillisThreshold) {
    return;
  }
  for (  Map.Entry<Class<? extends Move>,Integer> entry : totalCounts.entrySet()) {
    Class<? extends Move> moveClass=entry.getKey();
    double improved=improvementCounts.containsKey(moveClass) ? improvementCounts.get(moveClass) : 0.0;
    double total=entry.getValue();
    double ratio=improved / total;
    addPoint(moveClass,new ImprovingStepPercentageSingleStatisticPoint(timeMillisSpend,ratio));
  }
  improvementCounts.clear();
  totalCounts.clear();
  nextTimeMillisThreshold+=timeMillisThresholdInterval;
  if (nextTimeMillisThreshold < timeMillisSpend) {
    nextTimeMillisThreshold=timeMillisSpend;
  }
}
