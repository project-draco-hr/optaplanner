{
  String memberName=memberAccessor.getName();
  if (propertyAccessorMap.containsKey(memberName) || collectionPropertyAccessorMap.containsKey(memberName)) {
    MemberAccessor duplicate=propertyAccessorMap.get(memberName);
    if (duplicate == null) {
      duplicate=collectionPropertyAccessorMap.get(memberName);
    }
    throw new IllegalStateException("The solutionClass (" + solutionClass + ") has a "+ propertyAnnotationClass.getSimpleName()+ " annotated member ("+ memberAccessor+ ") that is duplicated by another member ("+ duplicate+ ").\n"+ "  Verify that the annotation is not defined on both the field and its getter.");
  }
  if (annotationClass.equals(propertyAnnotationClass)) {
    propertyAccessorMap.put(memberName,memberAccessor);
  }
 else   if (annotationClass.equals(collectionPropertyAnnotationClass)) {
    if (!Collection.class.isAssignableFrom(memberAccessor.getType())) {
      throw new IllegalStateException("The solutionClass (" + solutionClass + ") has a "+ collectionPropertyAnnotationClass.getSimpleName()+ " annotated member ("+ memberName+ ") that does not return a "+ Collection.class.getSimpleName()+ ".");
    }
    collectionPropertyAccessorMap.put(memberName,memberAccessor);
  }
}
