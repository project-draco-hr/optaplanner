{
  this.entitySelector=entitySelector;
  this.variableDescriptors=variableDescriptors;
  this.randomSelection=randomSelection;
  Class<?> entityClass=entitySelector.getEntityDescriptor().getPlanningEntityClass();
  for (  PlanningVariableDescriptor variableDescriptor : variableDescriptors) {
    if (!entityClass.equals(variableDescriptor.getEntityDescriptor().getPlanningEntityClass())) {
      throw new IllegalStateException("The selector (" + this + ") has a variableDescriptor ("+ variableDescriptor+ ") with a entityClass ("+ variableDescriptor.getEntityDescriptor().getPlanningEntityClass()+ ") which is not equal to the entitySelector's entityClass ("+ entityClass+ ").");
    }
    if (variableDescriptor.isChained()) {
      throw new IllegalStateException("The selector (" + this + ") has a variableDescriptor ("+ variableDescriptor+ ") which is chained ("+ variableDescriptor.isChained()+ ").");
    }
  }
  for (  PlanningVariableDescriptor variableDescriptor : variableDescriptors) {
    if (variableDescriptor.isChained()) {
      throw new IllegalStateException("The selector (" + this + ") cannot have a variableDescriptor ("+ variableDescriptor+ ") which is chained ("+ variableDescriptor.isChained()+ ").");
    }
  }
  if (entitySelector.isNeverEnding()) {
    throw new IllegalStateException("The selector (" + this + ") has an entitySelector ("+ entitySelector+ ") with neverEnding ("+ entitySelector.isNeverEnding()+ ").");
  }
  solverPhaseLifecycleSupport.addEventListener(entitySelector);
  solverPhaseLifecycleSupport.addEventListener(new SelectionCacheLifecycleBridge(CACHE_TYPE,this));
}
