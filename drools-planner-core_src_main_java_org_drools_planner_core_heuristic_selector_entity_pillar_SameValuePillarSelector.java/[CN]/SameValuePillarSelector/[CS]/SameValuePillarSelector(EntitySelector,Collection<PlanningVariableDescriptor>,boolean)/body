{
  this.entitySelector=entitySelector;
  this.variableDescriptors=variableDescriptors;
  this.randomSelection=randomSelection;
  Class<?> entityClass=entitySelector.getEntityDescriptor().getPlanningEntityClass();
  for (  PlanningVariableDescriptor variableDescriptor : variableDescriptors) {
    if (!entityClass.equals(variableDescriptor.getPlanningEntityDescriptor().getPlanningEntityClass())) {
      throw new IllegalStateException("The moveSelector (" + this.getClass() + ") has a variableDescriptor ("+ variableDescriptor+ ") with a planningEntityClass ("+ variableDescriptor.getPlanningEntityDescriptor().getPlanningEntityClass()+ ") which is not equal to the entitySelector's planningEntityClass ("+ entityClass+ ").");
    }
    if (variableDescriptor.isChained()) {
      throw new IllegalStateException("The pillarSelector (" + this.getClass() + ") has a variableDescriptor ("+ variableDescriptor+ ") which is chained ("+ variableDescriptor.isChained()+ ").");
    }
  }
  for (  PlanningVariableDescriptor variableDescriptor : variableDescriptors) {
    if (variableDescriptor.isChained()) {
      throw new IllegalStateException("The pillarSelector (" + this.getClass() + ") cannot have a variableDescriptor ("+ variableDescriptor+ ") which is chained ("+ variableDescriptor.isChained()+ ").");
    }
  }
  if (entitySelector.isNeverEnding()) {
    throw new IllegalStateException("The entitySelector (" + entitySelector + ") has neverEnding ("+ entitySelector.isNeverEnding()+ ") on a class ("+ getClass().getName()+ ") instance.");
  }
  solverPhaseLifecycleSupport.addEventListener(entitySelector);
  solverPhaseLifecycleSupport.addEventListener(new SelectionCacheLifecycleBridge(SelectionCacheType.STEP,this));
}
