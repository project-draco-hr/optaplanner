{
  this.leftEntitySelector=leftEntitySelector;
  this.rightEntitySelector=rightEntitySelector;
  this.variableDescriptors=variableDescriptors;
  this.randomSelection=randomSelection;
  PlanningEntityDescriptor leftEntityDescriptor=leftEntitySelector.getEntityDescriptor();
  PlanningEntityDescriptor rightEntityDescriptor=rightEntitySelector.getEntityDescriptor();
  if (!leftEntityDescriptor.getPlanningEntityClass().equals(rightEntityDescriptor.getPlanningEntityClass())) {
    throw new IllegalStateException("The selector (" + this + ") has a leftEntitySelector's entityClass ("+ leftEntityDescriptor.getPlanningEntityClass()+ ") which is not equal to the rightEntitySelector's entityClass ("+ rightEntityDescriptor.getPlanningEntityClass()+ ").");
  }
  boolean anyChained=false;
  if (variableDescriptors.isEmpty()) {
    throw new IllegalStateException("The selector (" + this + ")'s variableDescriptors ("+ variableDescriptors+ ") is empty.");
  }
  for (  PlanningVariableDescriptor variableDescriptor : variableDescriptors) {
    if (!leftEntityDescriptor.getPlanningEntityClass().equals(variableDescriptor.getPlanningEntityDescriptor().getPlanningEntityClass())) {
      throw new IllegalStateException("The selector (" + this + ") has a variableDescriptor with a entityClass ("+ variableDescriptor.getPlanningEntityDescriptor().getPlanningEntityClass()+ ") which is not equal to the leftEntitySelector's entityClass ("+ leftEntityDescriptor.getPlanningEntityClass()+ ").");
    }
    if (variableDescriptor.isChained()) {
      anyChained=true;
    }
  }
  this.anyChained=anyChained;
  solverPhaseLifecycleSupport.addEventListener(leftEntitySelector);
  if (leftEntitySelector != rightEntitySelector) {
    solverPhaseLifecycleSupport.addEventListener(rightEntitySelector);
  }
}
