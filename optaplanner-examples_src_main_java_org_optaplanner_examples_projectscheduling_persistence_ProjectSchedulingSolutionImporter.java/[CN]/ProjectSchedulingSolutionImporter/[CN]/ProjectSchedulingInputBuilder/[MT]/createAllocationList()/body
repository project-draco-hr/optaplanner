{
  List<Job> jobList=projectsSchedule.getJobList();
  List<Allocation> allocationList=new ArrayList<Allocation>(jobList.size());
  Map<Job,Allocation> jobToAllocationMap=new HashMap<Job,Allocation>(jobList.size());
  for (  Job job : jobList) {
    Allocation allocation=new Allocation();
    allocation.setId(job.getId());
    allocation.setJob(job);
    allocation.setPredecessorAllocationList(new ArrayList<Allocation>(job.getSuccessorJobList().size()));
    allocation.setSuccessorAllocationList(new ArrayList<Allocation>(job.getSuccessorJobList().size()));
    if (job.getJobType() == JobType.SOURCE) {
      allocation.setPredecessorsDoneDate(job.getProject().getReleaseDate());
      allocation.setDelay(0);
      if (job.getExecutionModeList().size() != 1) {
        throw new IllegalArgumentException("The job (" + job + ")'s executionModeList ("+ job.getExecutionModeList()+ ") is expected to be a singleton.");
      }
      allocation.setExecutionMode(job.getExecutionModeList().get(0));
    }
 else     if (job.getJobType() == JobType.SINK) {
      allocation.setDelay(0);
      if (job.getExecutionModeList().size() != 1) {
        throw new IllegalArgumentException("The job (" + job + ")'s executionModeList ("+ job.getExecutionModeList()+ ") is expected to be a singleton.");
      }
      allocation.setExecutionMode(job.getExecutionModeList().get(0));
    }
    allocationList.add(allocation);
    jobToAllocationMap.put(job,allocation);
  }
  for (  Allocation allocation : allocationList) {
    Job job=allocation.getJob();
    for (    Job successorJob : job.getSuccessorJobList()) {
      Allocation successorAllocation=jobToAllocationMap.get(successorJob);
      allocation.getSuccessorAllocationList().add(successorAllocation);
      successorAllocation.getPredecessorAllocationList().add(allocation);
    }
  }
  projectsSchedule.setAllocationList(allocationList);
}
