{
  LocalSearchSolverPhaseScope phaseScope=new LocalSearchSolverPhaseScope(solverScope);
  phaseStarted(phaseScope);
  LocalSearchStepScope stepScope=new LocalSearchStepScope(phaseScope);
  while (!termination.isPhaseTerminated(phaseScope)) {
    stepScope.setTimeGradient(termination.calculatePhaseTimeGradient(phaseScope));
    stepStarted(stepScope);
    decider.decideNextStep(stepScope);
    Move nextStep=stepScope.getStep();
    if (nextStep == null) {
      if (termination.isPhaseTerminated(phaseScope)) {
        logger.trace("    Step index ({}), time spend ({}) terminated without picking a nextStep.",stepScope.getStepIndex(),stepScope.getPhaseScope().calculateSolverTimeMillisSpend());
      }
 else       if (stepScope.getSelectedMoveCount() == 0L) {
        logger.warn("    No doable selected move at step index ({}), time spend ({})." + " Terminating phase early.",stepScope.getStepIndex(),stepScope.getPhaseScope().calculateSolverTimeMillisSpend());
      }
 else {
        throw new IllegalStateException("The step index (" + stepScope.getStepIndex() + ") has accepted/selected move count ("+ stepScope.getAcceptedMoveCount()+ "/"+ stepScope.getSelectedMoveCount()+ ") but failed to pick a nextStep ("+ nextStep+ ").");
      }
      break;
    }
    nextStep.doMove(stepScope.getScoreDirector());
    phaseScope.getWorkingSolution().setScore(stepScope.getScore());
    if (assertStepScoreIsUncorrupted) {
      phaseScope.assertWorkingScoreFromScratch(stepScope.getScore());
      phaseScope.assertExpectedWorkingScore(stepScope.getScore());
    }
    stepEnded(stepScope);
    phaseScope.setLastCompletedStepScope(stepScope);
    stepScope=new LocalSearchStepScope(phaseScope);
  }
  phaseEnded(phaseScope);
}
