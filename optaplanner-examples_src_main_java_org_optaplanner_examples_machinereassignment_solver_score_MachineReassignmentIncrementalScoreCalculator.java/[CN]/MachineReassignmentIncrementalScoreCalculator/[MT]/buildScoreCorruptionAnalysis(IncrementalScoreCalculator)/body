{
  MachineReassignmentIncrementalScoreCalculator other=(MachineReassignmentIncrementalScoreCalculator)uncorruptedIncrementalScoreCalculator;
  StringBuilder analysis=new StringBuilder();
  if (!serviceScorePartMap.keySet().equals(other.serviceScorePartMap.keySet())) {
    Collection excess=Sets.difference(serviceScorePartMap.keySet(),other.serviceScorePartMap.keySet());
    Collection lacking=Sets.difference(other.serviceScorePartMap.keySet(),serviceScorePartMap.keySet());
    analysis.append("  The serviceScorePartMap has in excess (").append(excess).append(") and is lacking (").append(lacking).append(").\n");
  }
 else {
    for (    Map.Entry<MrService,MrServiceScorePart> entry : serviceScorePartMap.entrySet()) {
      MrService service=entry.getKey();
      MrServiceScorePart part=entry.getValue();
      MrServiceScorePart otherPart=other.serviceScorePartMap.get(service);
      if (!part.locationBag.equals(otherPart.locationBag)) {
        Collection excess=Sets.difference((Set<Integer>)part.locationBag.values(),(Set<Integer>)otherPart.locationBag.values());
        Collection lacking=Sets.difference((Set<Integer>)otherPart.locationBag.values(),(Set<Integer>)part.locationBag.values());
        analysis.append("  On service (").append(service).append(") the locationBag has in excess (").append(excess).append(") and is lacking (").append(lacking).append(").\n");
      }
      if (!part.neighborhoodBag.equals(otherPart.neighborhoodBag)) {
        Collection excess=Sets.difference((Set<Integer>)part.neighborhoodBag.values(),(Set<Integer>)otherPart.neighborhoodBag.values());
        Collection lacking=Sets.difference((Set<Integer>)otherPart.neighborhoodBag.values(),(Set<Integer>)part.neighborhoodBag.values());
        analysis.append("  On service (").append(service).append(") the neighborhoodBag has in excess (").append(excess).append(") and is lacking (").append(lacking).append(").\n");
      }
      if (part.movedProcessCount != otherPart.movedProcessCount) {
        analysis.append("  On service (").append(service).append(") the movedProcessCount (").append(part.movedProcessCount).append(") is not correct (").append(otherPart.movedProcessCount).append(").\n");
      }
    }
  }
  return analysis.toString();
}
