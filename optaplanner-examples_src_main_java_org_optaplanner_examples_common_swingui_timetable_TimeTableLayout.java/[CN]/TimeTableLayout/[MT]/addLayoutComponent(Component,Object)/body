{
  TimeTableLayoutConstraints c=(TimeTableLayoutConstraints)o;
  if (c.getXEnd() > columns.size()) {
    throw new IllegalArgumentException("The xEnd (" + c.getXEnd() + ") is > columnsSize ("+ columns.size()+ ").");
  }
  if (c.getYEnd() > rows.size()) {
    throw new IllegalArgumentException("The yEnd (" + c.getYEnd() + ") is > rowsSize ("+ rows.size()+ ").");
  }
  ComponentSpan span=new ComponentSpan(component);
  spanMap.put(component,span);
  span.topLeftCell=cells.get(c.getX()).get(c.getY());
  span.bottomRightCell=cells.get(c.getXEnd() - 1).get(c.getYEnd() - 1);
  Set<Integer> occupiedCollisionIndexes=new HashSet<Integer>();
  for (int i=c.getX(); i < c.getXEnd(); i++) {
    for (int j=c.getY(); j < c.getYEnd(); j++) {
      Cell cell=cells.get(i).get(j);
      cell.spans.add(span);
      span.cells.add(cell);
      occupiedCollisionIndexes.addAll(cell.occupiedCollisionIndexes);
    }
  }
  Integer collisionIndex=0;
  while (occupiedCollisionIndexes.contains(collisionIndex)) {
    collisionIndex++;
  }
  if (c.isFillCollisions()) {
    if (collisionIndex != 0 || occupiedCollisionIndexes.contains(FILL_COLLISIONS_FLAG)) {
      throw new IllegalArgumentException("There is a collision with fillCollisions (" + c.isFillCollisions() + ").");
    }
    collisionIndex=FILL_COLLISIONS_FLAG;
  }
  span.collisionIndex=collisionIndex;
  int componentWidth=span.getPreferredWidthPerCell();
  for (  Cell cell : span.cells) {
    cell.occupiedCollisionIndexes.add(collisionIndex);
    Column column=cell.column;
    if (column.autoWidth) {
      if (column.baseWidth < componentWidth) {
        totalColumnWidth+=componentWidth - column.baseWidth;
        column.baseWidth=componentWidth;
      }
    }
    int collisionCount=cell.occupiedCollisionIndexes.size();
    Row row=cell.row;
    if (row.collisionCount < collisionCount) {
      row.collisionCount=collisionCount;
      totalRowHeight+=row.baseHeight;
    }
  }
}
