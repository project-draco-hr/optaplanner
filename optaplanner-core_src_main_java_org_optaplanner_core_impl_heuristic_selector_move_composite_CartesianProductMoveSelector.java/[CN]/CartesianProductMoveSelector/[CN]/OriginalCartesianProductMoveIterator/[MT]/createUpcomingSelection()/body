{
  int startingIndex;
  List<Move> moveList;
  if (subSelections == null) {
    startingIndex=-1;
    moveList=new ArrayList<Move>(childMoveSelectorList.size());
  }
 else {
    startingIndex=moveIteratorList.size() - 1;
    while (startingIndex >= 0) {
      Iterator<Move> moveIterator=moveIteratorList.get(startingIndex);
      if (moveIterator.hasNext()) {
        break;
      }
      startingIndex--;
    }
    if (startingIndex < 0) {
      return noUpcomingSelection();
    }
    moveList=new ArrayList<Move>(subSelections.subList(0,startingIndex));
    moveList.add(moveIteratorList.get(startingIndex).next());
  }
  for (int i=startingIndex + 1; i < moveIteratorList.size(); i++) {
    Iterator<Move> moveIterator=childMoveSelectorList.get(i).iterator();
    moveIteratorList.set(i,moveIterator);
    Move next;
    if (!moveIterator.hasNext()) {
      if (ignoreEmptyChildIterators) {
        next=EMPTY_MARK;
      }
 else {
        return noUpcomingSelection();
      }
    }
 else {
      next=moveIterator.next();
    }
    moveList.add(next);
  }
  subSelections=moveList;
  if (ignoreEmptyChildIterators) {
    moveList=new ArrayList<Move>(moveList);
    for (Iterator<Move> it=moveList.iterator(); it.hasNext(); ) {
      Move move=it.next();
      if (move == EMPTY_MARK) {
        it.remove();
      }
    }
    if (moveList.isEmpty()) {
      return noUpcomingSelection();
    }
 else     if (moveList.size() == 1) {
      return moveList.get(0);
    }
  }
  return new CompositeMove(moveList);
}
