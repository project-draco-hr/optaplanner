{
  List<GlobalResource> globalResourceList=projectsSchedule.getGlobalResourceList();
  List<LocalResource> localResourceList=projectsSchedule.getLocalResourceList();
  resourceCapacityTrackerMap=new HashMap<Resource,ResourceCapacityTracker>(globalResourceList.size() + localResourceList.size());
  for (  Resource resource : globalResourceList) {
    resourceCapacityTrackerMap.put(resource,resource.isRenewable() ? new RenewableResourceCapacityTracker(resource) : new NonrenewableResourceCapacityTracker(resource));
  }
  for (  Resource resource : localResourceList) {
    resourceCapacityTrackerMap.put(resource,resource.isRenewable() ? new RenewableResourceCapacityTracker(resource) : new NonrenewableResourceCapacityTracker(resource));
  }
  hardScore=0;
  mediumScore=0;
  softScore=0;
  totalProjectDelay=0;
  minimalReleaseDate=Integer.MAX_VALUE;
  maximalEndDate=0;
  for (  Project p : projectsSchedule.getProjectList()) {
    minimalReleaseDate=Math.min(p.getReleaseDate(),minimalReleaseDate);
  }
  projectDelayMap=new HashMap<Project,Integer>();
  allocationsPerProjectMap=new HashMap<Project,Set<Allocation>>();
  for (  Allocation allocation : projectsSchedule.getAllocationList()) {
    insert(allocation);
  }
}
