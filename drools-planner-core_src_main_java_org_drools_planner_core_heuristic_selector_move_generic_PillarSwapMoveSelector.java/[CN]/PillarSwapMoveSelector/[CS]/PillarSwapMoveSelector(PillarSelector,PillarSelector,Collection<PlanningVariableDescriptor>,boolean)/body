{
  this.leftPillarSelector=leftPillarSelector;
  this.rightPillarSelector=rightPillarSelector;
  this.variableDescriptors=variableDescriptors;
  this.randomSelection=randomSelection;
  leftEqualsRight=(leftPillarSelector == rightPillarSelector);
  Class<?> leftEntityClass=leftPillarSelector.getEntityDescriptor().getPlanningEntityClass();
  if (!leftEntityClass.equals(rightPillarSelector.getEntityDescriptor().getPlanningEntityClass())) {
    throw new IllegalStateException("The moveSelector (" + this.getClass() + ") has a leftPillarSelector's planningEntityClass ("+ leftEntityClass+ ") which is not equal to the rightPillarSelector's planningEntityClass ("+ rightPillarSelector.getEntityDescriptor().getPlanningEntityClass()+ ").");
  }
  for (  PlanningVariableDescriptor variableDescriptor : variableDescriptors) {
    if (!leftEntityClass.equals(variableDescriptor.getPlanningEntityDescriptor().getPlanningEntityClass())) {
      throw new IllegalStateException("The moveSelector (" + this.getClass() + ") has a variableDescriptor ("+ variableDescriptor+ ") with a planningEntityClass ("+ variableDescriptor.getPlanningEntityDescriptor().getPlanningEntityClass()+ ") which is not equal to the leftPillarSelector's planningEntityClass ("+ leftEntityClass+ ").");
    }
    if (variableDescriptor.isChained()) {
      throw new IllegalStateException("The moveSelector (" + this.getClass() + ") has a variableDescriptor ("+ variableDescriptor+ ") which is chained ("+ variableDescriptor.isChained()+ ").");
    }
  }
  solverPhaseLifecycleSupport.addEventListener(leftPillarSelector);
  solverPhaseLifecycleSupport.addEventListener(rightPillarSelector);
}
