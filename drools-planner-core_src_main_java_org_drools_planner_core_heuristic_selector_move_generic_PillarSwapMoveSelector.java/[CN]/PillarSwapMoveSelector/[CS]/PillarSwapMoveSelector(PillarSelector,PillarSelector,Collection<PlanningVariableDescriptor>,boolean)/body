{
  this.leftPillarSelector=leftPillarSelector;
  this.rightPillarSelector=rightPillarSelector;
  this.variableDescriptors=variableDescriptors;
  this.randomSelection=randomSelection;
  Class<?> leftEntityClass=leftPillarSelector.getEntityDescriptor().getPlanningEntityClass();
  if (!leftEntityClass.equals(rightPillarSelector.getEntityDescriptor().getPlanningEntityClass())) {
    throw new IllegalStateException("The selector (" + this + ") has a leftPillarSelector's planningEntityClass ("+ leftEntityClass+ ") which is not equal to the rightPillarSelector's planningEntityClass ("+ rightPillarSelector.getEntityDescriptor().getPlanningEntityClass()+ ").");
  }
  if (variableDescriptors.isEmpty()) {
    throw new IllegalStateException("The selector (" + this + ")'s variableDescriptors ("+ variableDescriptors+ ") is empty.");
  }
  for (  PlanningVariableDescriptor variableDescriptor : variableDescriptors) {
    if (!leftEntityClass.equals(variableDescriptor.getPlanningEntityDescriptor().getPlanningEntityClass())) {
      throw new IllegalStateException("The selector (" + this + ") has a variableDescriptor ("+ variableDescriptor+ ") with a planningEntityClass ("+ variableDescriptor.getPlanningEntityDescriptor().getPlanningEntityClass()+ ") which is not equal to the leftPillarSelector's planningEntityClass ("+ leftEntityClass+ ").");
    }
    if (variableDescriptor.isChained()) {
      throw new IllegalStateException("The selector (" + this + ") has a variableDescriptor ("+ variableDescriptor+ ") which is chained ("+ variableDescriptor.isChained()+ ").");
    }
  }
  solverPhaseLifecycleSupport.addEventListener(leftPillarSelector);
  if (leftPillarSelector != rightPillarSelector) {
    solverPhaseLifecycleSupport.addEventListener(rightPillarSelector);
  }
}
