{
  if (feasibilityScore) {
    if (compareBendableScoresHardLevelsOnly(score,startScore) <= 0) {
      return 0.0;
    }
  }
 else {
    startScore.validateCompatible(score);
    score.validateCompatible(endScore);
    if (score.compareTo(endScore) > 0) {
      return 1.0;
    }
 else     if (score.compareTo(startScore) < 0) {
      return 0.0;
    }
  }
  double timeGradient=0.0;
  double remainingTimeGradient=1.0;
  int levelCount=feasibilityScore ? hardLevelCount : hardLevelCount + softLevelCount;
  for (int i=0; i < levelCount; i++) {
    double levelTimeGradientWeight;
    if (i != (levelCount - 1)) {
      levelTimeGradientWeight=remainingTimeGradient * recursiveTimeGradientWeight;
      remainingTimeGradient-=levelTimeGradientWeight;
    }
 else {
      levelTimeGradientWeight=remainingTimeGradient;
    }
    int startScoreLevel=(i < hardLevelCount) ? startScore.getHardScore(i) : startScore.getSoftScore(i - hardLevelCount);
    int endScoreLevel=feasibilityScore ? 0 : (i < hardLevelCount) ? endScore.getHardScore(i) : endScore.getSoftScore(i - hardLevelCount);
    int scoreLevel=(i < hardLevelCount) ? score.getHardScore(i) : score.getSoftScore(i - hardLevelCount);
    if (scoreLevel >= endScoreLevel) {
      timeGradient+=levelTimeGradientWeight;
    }
 else {
      if (scoreLevel <= startScoreLevel) {
      }
 else {
        int levelTotal=endScoreLevel - startScoreLevel;
        int levelDelta=scoreLevel - startScoreLevel;
        double levelTimeGradient=(double)levelDelta / (double)levelTotal;
        timeGradient+=levelTimeGradient * levelTimeGradientWeight;
      }
    }
  }
  if (timeGradient > 1.0) {
    timeGradient=1.0;
  }
  return timeGradient;
}
