{
  WorkingMemory workingMemory=moveScope.getWorkingMemory();
  Move move=moveScope.getMove();
  Move undoMove=move.createUndoMove(workingMemory);
  moveScope.setUndoMove(undoMove);
  move.doMove(workingMemory);
  processMove(moveScope);
  undoMove.doMove(workingMemory);
  if (assertUndoMoveIsUncorrupted) {
    Score undoScore=moveScope.getLocalSearchStepScope().getLocalSearchSolverScope().calculateScoreFromWorkingMemory();
    Score lastCompletedStepScore=moveScope.getLocalSearchStepScope().getLocalSearchSolverScope().getLastCompletedLocalSearchStepScope().getScore();
    if (!undoScore.equals(lastCompletedStepScore)) {
      throw new IllegalStateException("Corrupted undo move (" + undoMove + ") received from move ("+ move+ ").\n"+ "Unequal lastCompletedStepScore ("+ lastCompletedStepScore+ ") and undoScore ("+ undoScore+ ").\n"+ moveScope.getLocalSearchStepScope().getLocalSearchSolverScope().buildConstraintOccurrenceSummary());
    }
  }
  logger.debug("    Move score ({}), accept chance ({}) for move ({}).",new Object[]{moveScope.getScore(),moveScope.getAcceptChance(),moveScope.getMove()});
}
