{
  if (plannerBenchmarkResult.getWarmUpTimeMillisSpentLimit() <= 0L) {
    return;
  }
  logger.info("================================================================================");
  logger.info("Warm up started");
  logger.info("================================================================================");
  long timeLeftTotal=plannerBenchmarkResult.getWarmUpTimeMillisSpentLimit();
  int parallelBenchmarkCount=plannerBenchmarkResult.getParallelBenchmarkCount();
  int solverBenchmarkResultCount=plannerBenchmarkResult.getSolverBenchmarkResultList().size();
  long cyclesCount=Math.round(Math.ceil(solverBenchmarkResultCount / (double)parallelBenchmarkCount));
  long timeLeftPerCycle=Math.round(Math.floor((timeLeftTotal / (double)cyclesCount)));
  ConcurrentMap<Future<SingleBenchmarkRunner>,SingleBenchmarkRunner> futureMap=new ConcurrentHashMap<Future<SingleBenchmarkRunner>,SingleBenchmarkRunner>(parallelBenchmarkCount);
  Map<SolverBenchmarkResult,TerminationConfig> originalTerminationConfigMap=new HashMap<SolverBenchmarkResult,TerminationConfig>(solverBenchmarkResultCount);
  ConcurrentMap<SolverBenchmarkResult,Integer> singleBenchmarkResultIndexMap=new ConcurrentHashMap<SolverBenchmarkResult,Integer>(solverBenchmarkResultCount);
  warmUpStarted(originalTerminationConfigMap);
  SolverBenchmarkResult[] solverBenchmarkResultCycleArray=new SolverBenchmarkResult[parallelBenchmarkCount];
  int solverBenchmarkResultIndex=0;
  for (int i=0; i < cyclesCount; i++) {
    long timeCycleEnd=System.currentTimeMillis() + timeLeftPerCycle;
    for (int j=0; j < parallelBenchmarkCount; j++) {
      solverBenchmarkResultCycleArray[j]=plannerBenchmarkResult.getSolverBenchmarkResultList().get(solverBenchmarkResultIndex % solverBenchmarkResultCount);
      solverBenchmarkResultIndex++;
    }
    warmUpPopulate(futureMap,singleBenchmarkResultIndexMap,solverBenchmarkResultCycleArray,timeLeftPerCycle);
    warmUp(futureMap,singleBenchmarkResultIndexMap,timeCycleEnd);
    futureMap.clear();
  }
  warmUpEnded(originalTerminationConfigMap);
  List<Runnable> notFinishedWarmUpList=warmUpExecutorService.shutdownNow();
  if (!notFinishedWarmUpList.isEmpty()) {
    throw new IllegalStateException("Impossible state: notFinishedWarmUpList is non-empty (" + notFinishedWarmUpList + ").");
  }
  logger.info("================================================================================");
  logger.info("Warm up ended");
  logger.info("================================================================================");
}
