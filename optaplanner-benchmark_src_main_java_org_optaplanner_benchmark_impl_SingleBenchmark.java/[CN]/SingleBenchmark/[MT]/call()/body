{
  Runtime runtime=Runtime.getRuntime();
  Solution inputSolution=problemBenchmark.readPlanningProblem();
  if (!problemBenchmark.getPlannerBenchmark().hasMultipleParallelBenchmarks()) {
    runtime.gc();
    usedMemoryAfterInputSolution=runtime.totalMemory() - runtime.freeMemory();
  }
  logger.trace("Benchmark inputSolution has been read for singleBenchmark ({}_{}).",problemBenchmark.getName(),solverBenchmark.getName());
  Solver solver=solverBenchmark.getSolverConfig().buildSolver();
  for (  ProblemStatistic problemStatistic : problemBenchmark.getProblemStatisticList()) {
    SingleStatistic singleStatistic=problemStatistic.createSingleStatistic(this);
    singleStatistic.open(solver);
    singleStatisticMap.put(problemStatistic.getProblemStatisticType(),singleStatistic);
  }
  solver.setPlanningProblem(inputSolution);
  solver.solve();
  Solution outputSolution=solver.getBestSolution();
  timeMillisSpend=solver.getTimeMillisSpend();
  DefaultSolverScope solverScope=((DefaultSolver)solver).getSolverScope();
  calculateCount=solverScope.getCalculateCount();
  score=outputSolution.getScore();
  SolutionDescriptor solutionDescriptor=((DefaultSolver)solver).getSolutionDescriptor();
  planningEntityCount=solutionDescriptor.getEntityCount(outputSolution);
  problemBenchmark.registerProblemScale(solutionDescriptor.getProblemScale(outputSolution));
  for (  SingleStatistic singleStatistic : singleStatisticMap.values()) {
    singleStatistic.close(solver);
  }
  problemBenchmark.writeOutputSolution(this,outputSolution);
  return this;
}
