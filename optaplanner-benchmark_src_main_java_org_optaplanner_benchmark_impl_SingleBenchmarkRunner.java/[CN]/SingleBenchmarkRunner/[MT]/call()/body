{
  Runtime runtime=Runtime.getRuntime();
  ProblemBenchmark problemBenchmark=singleBenchmarkResult.getProblemBenchmark();
  Solution inputSolution=problemBenchmark.readPlanningProblem();
  if (!problemBenchmark.getPlannerBenchmark().hasMultipleParallelBenchmarks()) {
    runtime.gc();
    singleBenchmarkResult.setUsedMemoryAfterInputSolution(runtime.totalMemory() - runtime.freeMemory());
  }
  logger.trace("Benchmark inputSolution has been read for singleBenchmarkResult ({}).",singleBenchmarkResult.getName());
  Solver solver=singleBenchmarkResult.getSolverBenchmark().getSolverConfig().buildSolver();
  for (  SingleStatistic singleStatistic : singleBenchmarkResult.getSingleStatisticMap().values()) {
    singleStatistic.open(solver);
  }
  solver.setPlanningProblem(inputSolution);
  solver.solve();
  long timeMillisSpend=solver.getTimeMillisSpend();
  Solution outputSolution=solver.getBestSolution();
  SolutionDescriptor solutionDescriptor=((DefaultSolver)solver).getSolutionDescriptor();
  singleBenchmarkResult.setPlanningEntityCount(solutionDescriptor.getEntityCount(outputSolution));
  problemBenchmark.registerProblemScale(solutionDescriptor.getProblemScale(outputSolution));
  singleBenchmarkResult.setScore(outputSolution.getScore());
  singleBenchmarkResult.setTimeMillisSpend(timeMillisSpend);
  DefaultSolverScope solverScope=((DefaultSolver)solver).getSolverScope();
  singleBenchmarkResult.setCalculateCount(solverScope.getCalculateCount());
  for (  SingleStatistic singleStatistic : singleBenchmarkResult.getSingleStatisticMap().values()) {
    singleStatistic.close(solver);
    singleStatistic.writeCsvStatisticFile();
  }
  problemBenchmark.writeOutputSolution(singleBenchmarkResult,outputSolution);
  return this;
}
