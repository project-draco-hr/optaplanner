{
  Set<ConstraintOccurrence> workingConstraintOccurrenceSet=new LinkedHashSet<ConstraintOccurrence>();
  Iterator<ConstraintOccurrence> workingIt=(Iterator<ConstraintOccurrence>)workingMemory.iterateObjects(new ClassObjectFilter(ConstraintOccurrence.class));
  while (workingIt.hasNext()) {
    workingConstraintOccurrenceSet.add(workingIt.next());
  }
  Set<ConstraintOccurrence> uncorruptedConstraintOccurrenceSet=new LinkedHashSet<ConstraintOccurrence>();
  Iterator<ConstraintOccurrence> uncorruptedIt=(Iterator<ConstraintOccurrence>)uncorruptedSolutionDirector.getWorkingMemory().iterateObjects(new ClassObjectFilter(ConstraintOccurrence.class));
  while (uncorruptedIt.hasNext()) {
    uncorruptedConstraintOccurrenceSet.add(uncorruptedIt.next());
  }
  ;
  Set<Object> excessSet=new LinkedHashSet<Object>(workingConstraintOccurrenceSet);
  excessSet.removeAll(uncorruptedConstraintOccurrenceSet);
  Set<Object> lackingSet=new LinkedHashSet<Object>(uncorruptedConstraintOccurrenceSet);
  lackingSet.removeAll(workingConstraintOccurrenceSet);
  int CONSTRAINT_OCCURRENCE_DISPLAY_LIMIT=10;
  StringBuilder analysis=new StringBuilder();
  if (!excessSet.isEmpty()) {
    analysis.append("  The workingMemory has ").append(excessSet.size()).append(" ConstraintOccurrence(s) in excess:\n");
    int count=0;
    for (    Object o : excessSet) {
      if (count >= CONSTRAINT_OCCURRENCE_DISPLAY_LIMIT) {
        analysis.append("    ... ").append(excessSet.size() - CONSTRAINT_OCCURRENCE_DISPLAY_LIMIT).append(" more\n");
        break;
      }
      analysis.append("    ").append(o.toString()).append("\n");
      count++;
    }
  }
  if (!lackingSet.isEmpty()) {
    analysis.append("  The workingMemory has ").append(excessSet.size()).append(" ConstraintOccurrence(s) lacking:\n");
    int count=0;
    for (    Object o : lackingSet) {
      if (count >= CONSTRAINT_OCCURRENCE_DISPLAY_LIMIT) {
        analysis.append("    ... ").append(lackingSet.size() - CONSTRAINT_OCCURRENCE_DISPLAY_LIMIT).append(" more\n");
        break;
      }
      analysis.append("    ").append(o.toString()).append("\n");
      count++;
    }
  }
  if (excessSet.isEmpty() && lackingSet.isEmpty()) {
    analysis.append("  Check the score rules. No ConstraintOccurrence(s) in excess or lacking." + "  Possibly some logically inserted score rules do not extend ConstraintOccurrence.\n" + "  Consider making them extend ConstraintOccurrence"+ " or just reuse the build-in ConstraintOccurrence implementations.");
  }
 else {
    analysis.append("  Check the score rules who created those ConstraintOccurrences." + " Verify that each ConstraintOccurrence's causes and weight is correct.");
  }
  return analysis.toString();
}
